(function(a) {'use strict'; function b(a) {const b = {id: a.id, label: a.label}; return a.viz && (b.viz = a.viz), a.attributes && (b.attributes = a.attributes), b;} function c(a) {const b = {id: a.id, type: a.type || 'undirected', label: a.label || '', source: a.source, target: a.target, weight: +a.weight || 1}; return a.viz && (b.viz = a.viz), a.attributes && (b.attributes = a.attributes), b;} function d(a) {function d() {const a = {}; return l.els.meta ? (a.lastmodifieddate = l.els.meta.getAttribute('lastmodifieddate'), h.nodeListEach(l.els.meta.childNodes, function(b) {a[b.tagName.toLowerCase()] = b.textContent;}), a) : a;} function e(a) {const b = []; return l.els.model[a] && h.nodeListEach(l.els.model[a], function(a) {let c = {id: a.getAttribute('id') || a.getAttribute('for'), type: a.getAttribute('type') || 'string', title: a.getAttribute('title') || ''}, d = h.nodeListToArray(a.childNodes); d.length > 0 && (c.defaultValue = d[0].textContent), b.push(c);}), b.length > 0 && b;} function f(a, b) {let c = {}, d = b.getElementsByTagName('attvalue'), e = h.nodeListToHash(d, function(a) {let b = h.namedNodeMapToObject(a.attributes), c = b.id || b.for; return {key: c, value: b.value};}); return a.map(function(a) {c[a.id] = !(a.id in e) && 'defaultValue'in a ? h.enforceType(a.type, a.defaultValue) : h.enforceType(a.type, e[a.id]);}), c;} function g(a) {const c = []; return h.nodeListEach(l.els.nodes, function(d) {const e = {id: d.getAttribute('id'), label: d.getAttribute('label') || ''}; a && (e.attributes = f(a, d)), l.hasViz && (e.viz = i(d)), c.push(b(e));}), c;} function i(a) {let b = {}, c = h.getFirstElementByTagNS(a, 'viz', 'color'); if (c) {const d = ['r', 'g', 'b', 'a'].map(function(a) {return c.getAttribute(a);}); b.color = h.getRGB(d);} const e = h.getFirstElementByTagNS(a, 'viz', 'position'); e && (b.position = {}, ['x', 'y', 'z'].map(function(a) {b.position[a] = +e.getAttribute(a);})); const f = h.getFirstElementByTagNS(a, 'viz', 'size'); f && (b.size = +f.getAttribute('value')); const g = h.getFirstElementByTagNS(a, 'viz', 'shape'); return g && (b.shape = g.getAttribute('value')), b;} function j(a, b) {const d = []; return h.nodeListEach(l.els.edges, function(e) {const g = h.namedNodeMapToObject(e.attributes); 'type'in g || (g.type = b), a && (g.attributes = f(a, e)), l.hasViz && (g.viz = k(e)), d.push(c(g));}), d;} function k(a) {let b = {}, c = h.getFirstElementByTagNS(a, 'viz', 'color'); if (c) {const d = ['r', 'g', 'b', 'a'].map(function(a) {return c.getAttribute(a);}); b.color = h.getRGB(d);} const e = h.getFirstElementByTagNS(a, 'viz', 'shape'); e && (b.shape = e.getAttribute('value')); const f = h.getFirstElementByTagNS(a, 'viz', 'thickness'); return f && (b.thickness = +f.getAttribute('value')), b;} const l = {}; l.els = {root: a.getElementsByTagName('gexf')[0], graph: a.getElementsByTagName('graph')[0], meta: a.getElementsByTagName('meta')[0], nodes: a.getElementsByTagName('node'), edges: a.getElementsByTagName('edge'), model: h.getModelTags(a)}, l.hasViz = !!h.getAttributeNS(l.els.root, 'xmlns', 'viz'), l.version = l.els.root.getAttribute('version') || '1.0', l.mode = l.els.graph.getAttribute('mode') || 'static'; const m = l.els.graph.getAttribute('defaultedgetype'); l.defaultEdgetype = m || 'undirected'; let n = e('node'), o = e('edge'), p = {version: l.version, mode: l.mode, defaultEdgeType: l.defaultEdgetype, meta: d(), model: {}, nodes: g(n), edges: j(o, l.defaultEdgetype)}; return n && (p.model.node = n), o && (p.model.edge = o), p;} function e(a, b) {const c = (function() {if (window.XMLHttpRequest) return new XMLHttpRequest; let a, b; if (window.ActiveXObject) {a = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Msxml2.XMLHTTP', 'Microsoft.XMLHTTP']; for (b in a) try {return new ActiveXObject(a[b]);} catch (a) {}} return null;}()); if (!c) throw 'XMLHttpRequest not supported, cannot load the file.'; let d, e = typeof b == 'function'; return c.overrideMimeType ? (c.overrideMimeType('text/xml'), d = function(a) {return a.responseXML;}) : d = function(a) {const b = new DOMParser; return b.parseFromString(a.responseText, 'application/xml');}, c.open('GET', a, e), e && (c.onreadystatechange = function() {c.readyState === 4 && b(d(c));}), c.send(), e ? c : d(c);} function f(a) {return d(a);} function g(a, b) {return typeof b == 'function' ? e(a, function(a) {b(d(a));}) : d(e(a));} const h = {getModelTags(a) {let b, c = a.getElementsByTagName('attributes'), d = {}, e = c.length; for (b = 0; b < e; b++)d[c[b].getAttribute('class')] = c[b].childNodes; return d;}, nodeListToArray(a) {for (var b = [], c = 0, d = a.length; c < d; ++c)a[c].nodeName !== '#text' && b.push(a[c]); return b;}, nodeListEach(a, b) {for (let c = 0, d = a.length; c < d; ++c)a[c].nodeName !== '#text' && b(a[c]);}, nodeListToHash(a, b) {for (var c = {}, d = 0; d < a.length; d++) if (a[d].nodeName !== '#text') {const e = b(a[d]); c[e.key] = e.value;} return c;}, namedNodeMapToObject(a) {for (var b = {}, c = 0; c < a.length; c++)b[a[c].name] = a[c].value; return b;}, getFirstElementByTagNS(a, b, c) {let d = a.getElementsByTagName(b + ':' + c)[0]; return d || (d = a.getElementsByTagNameNS(b, c)[0]), d || (d = a.getElementsByTagName(c)[0]), d;}, getAttributeNS(b, c, d) {let e = b.getAttribute(c + ':' + d); return e === a && (e = b.getAttributeNS(c, d)), e === a && (e = b.getAttribute(d)), e;}, enforceType(a, b) {switch (a) {case 'boolean':b = b === 'true'; break; case 'integer':case 'long':case 'float':case 'double':b = +b; break; case 'liststring':b = b ? b.split('|') : [];} return b;}, getRGB(a) {return a[3] ? 'rgba(' + a.join(',') + ')' : 'rgb(' + a.slice(0, -1).join(',') + ')';}}; if (typeof this.gexf != 'undefined') throw 'gexf: error - a variable called "gexf" already exists in the global scope'; this.gexf = {parse: f, fetch: g, version: '0.1.1'}, typeof exports != 'undefined' && this.exports !== exports && (module.exports = this.gexf);}).call(this), function(a) {'use strict'; function b() {return 'e' + c++;} if (typeof sigma == 'undefined') throw 'sigma is not declared'; sigma.utils.pkg('sigma.parsers'); let c = 0; sigma.parsers.gexf = function(a, c, d) {function e(a) {for (h = a.nodes, f = 0, g = h.length; f < g; f++)i = h[f], i.id = i.id, i.viz && typeof i.viz == 'object' && (i.viz.position && typeof i.viz.position == 'object' && (i.x = i.viz.position.x, i.y = -i.viz.position.y), i.size = i.viz.size, i.color = i.viz.color); for (h = a.edges, f = 0, g = h.length; f < g; f++)i = h[f], i.id = typeof i.id == 'string' ? i.id : b(), i.source = '' + i.source, i.target = '' + i.target, i.viz && typeof i.viz == 'object' && (i.color = i.viz.color, i.size = i.viz.thickness), i.size = i.weight, i.direction = i.type, delete i.type; if (c instanceof sigma) {for (c.graph.clear(), h = a.nodes, f = 0, g = h.length; f < g; f++)c.graph.addNode(h[f]); for (h = a.edges, f = 0, g = h.length; f < g; f++)c.graph.addEdge(h[f]);} else typeof c == 'object' ? (c.graph = a, c = new sigma(c)) : typeof c == 'function' && (d = c, c = null); return d ? void d(c || a) : a;} let f, g, h, i; if (typeof a == 'string')gexf.fetch(a, e); else if (typeof a == 'object') return e(gexf.parse(a));};}.call(this);
